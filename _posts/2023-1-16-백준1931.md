---
layout: post
title: 백준 1931번
---

<h2>백준 1931번</h2>

<h3>회의실 배정</h3>

<h3>시간 제한 : 2초   메모리 제한 : 128 MB</h3>


<h3>문제</h3>

한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.
<h3>입력</h3>

첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.


<h3>출력</h3>

첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

​

<h3>해설</h3>

이 문제는 각 회의의 시작 시간과 끝나는 시간을 바탕으로 최대한 많은 회의를 진행할 수 있는 시간표를 작성하는 문제입니다.

해결 방법은 다음과 같습니다:

1. 구조체 정의: room이라는 구조체를 정의하여 각 회의의 시작 시간(s)과 끝나는 시간(e)을 저장합니다.
2. 정렬 기준 설정: compare 함수를 사용하여 회의들을 끝나는 시간을 기준으로 오름차순으로 정렬합니다. 만약 끝나는 시간이 같다면 시작 시간을 기준으로 오름차순 정렬합니다.
3. 메인 함수:
회의의 개수를 입력받습니다.
각 회의의 시작 시간과 끝나는 시간을 입력받아 room 구조체 배열에 저장합니다.
qsort 함수를 사용하여 회의들을 정렬합니다.
첫 번째 회의는 무조건 선택됩니다. 그 다음부터는 현재 선택된 회의의 끝나는 시간 이후에 시작하는 회의 중 가장 먼저 끝나는 회의를 선택합니다.
선택된 회의의 개수를 출력합니다.
이 방식은 그리디 알고리즘의 한 예입니다. 끝나는 시간을 기준으로 회의를 정렬하여 항상 가능한 시간 중 가장 먼저 끝나는 회의를 선택함으로써 최대한 많은 회의를 진행할 수 있습니다.

```c

#define _CRT_SECURE_NO_WARNINGS    
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

typedef struct room {
	int s;
	int e;
} room;

int compare(const void* a, const void* b) {
	room num1 = *(room*)a;
	room num2 = *(room*)b;
	if (num1.e > num2.e)
	{
		return 1;
	}
	else if (num1.e == num2.e)
	{
		if (num1.s > num2.s)
		{
			return 1;
		}
		else {
			return -1;
		}
	}
	return -1;
}

int main() {
	int a, lowe = 25;
	scanf("%d", &a);
	room z[a];
	for (int i = 0; i < a; i++)
	{
		scanf("%d %d", &z[i].s, &z[i].e);
	}
	qsort(z, a, sizeof(room), compare);
	int k = 0, count = 1;
	for (int i = 1; i < a; i++)
	{
		if (z[k].e <= z[i].s) {
			count++;
			k = i;
		}
	}
	printf("%d", count);
}

```